// Добавление метода в прототип Object
Object.prototype.inherit = function (Parent) {
  // 1. Создание промежуточного конструктора.
  // Создается пустая функция F, и ее прототип устанавливается 
  // равным прототипу родительского класса. Это нужно для разрыва прямой связи прототипов.
  const F = function () {};
  F.prototype = Parent.prototype;
  // 2. Установка цепочки прототипов
  // Создается экземпляр F, который становится прототипом текущего конструктора (дочернего класса). Благодаря этому:
  // - Дочерний класс получает все методы родителя
  // - Не вызывается конструктор родителя при создании связи
  this.prototype = new F();
  // 3. Восстановление конструктора
  // После замены прототипа свойство constructor сбрасывается. 
  // Эта строка восстанавливает правильную ссылку на конструктор дочернего класса.
  this.prototype.constructor = this;
  // 4. Сохранение ссылки на родительский прототип
  // Конструктор дочернего класса получает свойство superclass, ссылающееся на прототип родителя.
  this.superclass = Parent.prototype;
  // 5. Добавление метода для вызова родительского конструктора
  // В прототип дочернего класса добавляется метод _super, 
  // который позволяет вызывать конструктор родителя в контексте текущего экземпляра.
  this.prototype._super = function () {
    Parent.apply(this, arguments);
  };
};

function Main() {
  this.a = 100;
}

Main.prototype.method = function (param) {
  return `param: ${param}`;
};

function Box() {
  this._super();
}

Box.inherit(Main);

Box.prototype.getMainProps = function () {
  return this;
};
